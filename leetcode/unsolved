class Solution:
    def find_pivot_or_luck(self, nums: List[int], target: List[int], l: int, r: int, _fst: int):
        while l < r:
            mid = l + (r - l) // 2
            curr = nums[mid]

            if curr == target:
                return mid, True
 
            if curr > _fst:
                nxt = nums[mid + 1] 
                if mid + 1 < len(nums) and nxt < _fst:
                    return mid + 1, nxt == target
                l = mid + 1
                
            else:  # curr <= _fst
                prev = nums[mid - 1]
                if prev > _fst:
                    return mid, prev == target
                
                r = mid - 1
        return r

    def find(self, nums: List[int], target: int, l: int, r: int):
        if (l > r or 0 > l or 0 > r or len(nums) <= r or len(nums) <= l):
            return False
        
        if l == r:
            return nums[l]
        
        mid = l + (r - l) // 2
        curr = nums[mid]

        if curr == target:
            return mid

        if curr < target:
            return self.find(nums, target, mid + 1, r)
        return self.find(nums, target, l, mid)

    def search(self, nums: List[int], target: int) -> int:
        indx, luck = self.find_pivot_or_luck(nums, target, 0, 
                                            len(nums), nums[0])
        if luck:
            return indx

        if target < nums[0]:
            return self.find(nums, target, indx + 1, len(nums))
        return self.find(nums, target, 1, indx)
